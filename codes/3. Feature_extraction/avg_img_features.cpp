/*
This code takes as input all the files generated by Main_for_shots.cpp (i.e. all the face frames), and generates feature files
for every face track that has >=3 frames. The features available in the code are:
1. Average image i.e. average of all the images of a face track (size 102x102 pixels)
2. LBP image of that average image (size 100x100 pixels)
*/



/////////libraries//////////
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/videoio/videoio.hpp"
#include "opencv2/highgui/highgui.hpp"
#include <iostream>
#include "mmr_lib.h"

using namespace cv;
using namespace std;

int main(){

	int i, j, k, l,id,x,y;
	int ri, rj;
	char *str;
	bool flag = false;
	int falsecases = 0;
	int truecases = 0;
	Mat temp;
	int tukdai, tukdaj;
	int pc = 0;
	int ix, iy, iwidth, iheight;

	int widthslices = 4;
	int heightslices = 4;
	int framecount = 20;

//**************parameters to tweak************//
	int falseadd = 1;				//it is one when a 'minute' doesn't give any representative face data
	int bgrSum[3];
	Vec3b bgr;
//********************************************//

	vector <cv::Mat> avgImageRGBchannels2;
	Mat avgImageRGBchannels[3];
	std::vector<cv::Mat> vecImg, vecImgPiece;
	Mat hist(3, 59, CV_32FC1);
	Mat channel;
	vecImgPiece.resize(framecount);


	system("md avgimgdata");			//stores the avg images, 1 for every face track
	system("md LBPofavgImg");			//stores the LBP of the average images

	Mat averageImage = Mat(102, 102, CV_8UC3);

	for (j = 0; j <= 1500; j++){
		for (id = 0; id < 10; id++){
			flag = false;
			vecImg.clear();
//			cout << "Size: " << vecImg.size() << endl;
			for (i = 0; i < 20; i++){
				str = get_string_id(j, id, i, "data\\");
				temp = imread(str);
				if (temp.empty()){
					flag = true;
					break;
				}

				Mat temp2;
				resize(temp, temp2, Size(102, 102));
				vecImg.push_back(temp2);
			}
			if (i >= 3){

				//				cout << "size: " << i;
				falseadd = 0;
				truecases += 1;
				str = get_string_id2(j, id, "avgimgdata\\");
				//std::cout << str << endl;
				
				//fill the average image
				for (x = 0; x < 102; x++){
					for (y = 0; y < 102; y++){
						for (k = 0; k < 3; k++){
							bgrSum[k] = 0;
						}
						for (l = 0; l < i; l++){
							//get the sum
							bgr = vecImg[l].at<Vec3b>(x,y);
							for (k = 0; k < 3; k++){
								bgrSum[k] = bgrSum[k] + (int)bgr[k];
							}
						}
						for (k = 0; k < 3; k++){
							bgrSum[k] = int(bgrSum[k] / 20.0);
							bgr[k] = (uint)bgrSum[k];
						}
						averageImage.at<Vec3b>(x,y) = bgr;
					}
				}
				cv::imwrite(str, averageImage);
				split(averageImage, avgImageRGBchannels);
				avgImageRGBchannels2.clear();
				for (k = 0; k < 3; k++){
					OLBP(&avgImageRGBchannels[k], &channel);
					avgImageRGBchannels2.push_back(channel);
				}
				Mat mergedavgImageRGBchannelsImage;
				merge(avgImageRGBchannels2, mergedavgImageRGBchannelsImage);
				str = get_string_id2(j + 100000, id, "LBPofavgImg\\");
				imwrite(str, mergedavgImageRGBchannelsImage);
			}
		}
		falsecases = falsecases + falseadd;
		falseadd = 1;
	}

	std::cout << "Results: " << "\tTrueCases: " << truecases << "\tfalseCases: " << falsecases << "\nPress ENTER key to exit\n";
	getchar();
	return 0;

}
