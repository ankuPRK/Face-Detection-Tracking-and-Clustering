/*
This code takes as input all the files generated by Main_for_shots.cpp (i.e. all the face frames), and generates feature files
for every face track that has >=3 frames. The features available in the code are:
1. Volume LBP
2. LBP TOP (Three Orthogonal Planes)
3. Volume HOG (Histogram of Oriented Gradients)
4. HOG-TOP


*/

/////////libraries//////////
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/videoio/videoio.hpp"
#include "opencv2/highgui/highgui.hpp"
#include <iostream>
#include "mmr_lib.h"
#include "3D_features.h"

using namespace cv;
using namespace std;

int main(){

	std::vector<cv::Mat> vecImgB, vecImgG, vecImgR, vecImgPieceB, vecImgPieceG, vecImgPieceR, bgr;
	int i, j, k, id;
	int ri, rj;
	int framecount = 20;
	char *str;
	bool flag = false;
	int falsecases = 0;
	int truecases = 0;
	vecImgR.resize(framecount);
	vecImgG.resize(framecount);
	vecImgB.resize(framecount);
	vecImgPieceB.resize(framecount);
	vecImgPieceG.resize(framecount);
	vecImgPieceR.resize(framecount);
	Mat temp;
	int tukdai, tukdaj;
	int pc = 0;
	int ix, iy, iwidth, iheight;

//************** Parameters to tweak ********************//
	int widthslices = 3;
	int heightslices = 3 ;
	int falseadd = 1;				//it is one when a 'minute' doesn't give any representative face data
	float overlap = 0.1;			//ratio of overlapped width/height of part wrt the original piece's width/height  
	int method = 0; // Set 0: LBP-TOP, 1: Volume LBP, 2: HOG-TOP, 4: Volume HOG 


	int singleHistogramSize = (method == 0 || method == 1)* 59 + (method == 2 || method == 3)*8;	//59 if using LBP, 8 if using HOG
	Mat hist(3, singleHistogramSize, CV_32FC1);
//********************************************************//

	system("md histodata");		//stores the Concatenated Histogram for each track, 
								//name of each feature track file is mmmmmmii . txt mmmmmm: 'track count' 
								//ii: id of face for a part. 'minute' count
	system("md imgdata");		//stores the middle frame of each track, to represent the fetaures obtained  
								//name of each feature track file is mmmmmmii . jpg 1mmmmm: 'track count'
								//ii: id of face for a part. 'minute' count


	for (j = 0; j <= 1500; j++){
		for (id = 0; id < 10; id++){
		//the upperlimits of the upper two loops has to be 
		//	id's upper limit >= upon the max. faces possible in 1 frame, and
		// j's upper limit >= max. minute count

			flag = false;
			for (i = 0; i < framecount; i++){
				str = get_string_id(j, id, i, "data25\\");
				temp = imread(str);
				if (temp.empty()){
					flag = true;
					break;
				}
				split(temp, bgr);
				if (i == 0){
					resize(bgr[0], vecImgB[0], Size(bgr[0].cols, bgr[0].rows));
					resize(bgr[1], vecImgG[0], Size(bgr[1].cols, bgr[1].rows));
					resize(bgr[2], vecImgR[0], Size(bgr[2].cols, bgr[2].rows));
				}
				else{
					resize(bgr[0], vecImgB[i], Size(vecImgB[0].cols, vecImgB[0].rows));
					resize(bgr[1], vecImgG[i], Size(vecImgG[0].cols, vecImgG[0].rows));
					resize(bgr[2], vecImgR[i], Size(vecImgR[0].cols, vecImgR[0].rows));
				}
			}
			if (i>=3){

				falseadd = 0;
				truecases += 1;
				str = get_array_string(j, id, "histodata\\");
				//std::cout << str << endl;
				ofstream out(str, std::ofstream::out);
				for (tukdai = 0; tukdai < widthslices; tukdai++){
					for (tukdaj = 0; tukdaj < heightslices; tukdaj++){
						vecImgPieceB.resize(i);
						vecImgPieceG.resize(i);
						vecImgPieceR.resize(i);

						//split track into widthslices*heightslices no. of pieces in XY axis
						//overlap can be set by modifying overlap variable
						//Histogram for each R, G, B, channel is computed for each piece, and then all are concatenated.
						for (pc = 0; pc < i; pc++){
							ix = (vecImgR[0].cols*tukdai) / widthslices - (vecImgR[0].cols*overlap) / widthslices;
							iy = (vecImgR[0].rows*tukdaj) / heightslices - (vecImgR[0].rows*overlap) / heightslices;
							iwidth = (vecImgR[0].cols*(tukdai + 1)) / widthslices - (vecImgR[0].cols*tukdai) / widthslices + ((vecImgR[0].cols*overlap) / widthslices) * 2;
							iheight = (vecImgR[0].rows*(tukdaj + 1)) / heightslices - (vecImgR[0].rows*tukdaj) / heightslices + ((vecImgR[0].rows*overlap) / heightslices) * 2;

							if (tukdai == 0){
								ix = 0;
								iwidth = (vecImgR[0].cols*(tukdai + 1)) / widthslices - (vecImgR[0].cols*tukdai) / widthslices + ((vecImgR[0].cols*overlap) / widthslices) ;
							}
							if (tukdaj == 0){
								iy = 0;
								iheight = (vecImgR[0].rows*(tukdaj + 1)) / heightslices - (vecImgR[0].rows*tukdaj) / heightslices + ((vecImgR[0].rows*overlap) / heightslices) ;
							}
							if (tukdai == widthslices - 1){
								iwidth = (vecImgR[0].cols*(tukdai + 1)) / widthslices - (vecImgR[0].cols*tukdai) / widthslices + ((vecImgR[0].cols*overlap) / widthslices);
							}
							if (tukdaj == heightslices - 1){
								iheight = (vecImgR[0].rows*(tukdaj + 1)) / heightslices - (vecImgR[0].rows*tukdaj) / heightslices + ((vecImgR[0].rows*overlap) / heightslices);
							}
							vecImgR[pc](cv::Rect(int(ix),int(iy),int(iwidth),int(iheight))).copyTo(vecImgPieceR[pc]);
							vecImgG[pc](cv::Rect(int(ix), int(iy), int(iwidth), int(iheight))).copyTo(vecImgPieceG[pc]);
							vecImgB[pc](cv::Rect(int(ix), int(iy), int(iwidth), int(iheight))).copyTo(vecImgPieceB[pc]);
							// cout << "ti: " << tukdai << " tj: " << tukdaj << endl;
						}

						switch (method){
							case 0:
							LBP_TOP(vecImgPieceB, i, vecImgPieceB[0].rows, vecImgPieceB[0].cols, 1, 1, 1, 8, 8, 8, 1, 1, singleHistogramSize, false, hist);
							break;
							case 1:
								volume_LBP(vecImgPieceB, i, vecImgPieceB[0].rows, vecImgPieceB[0].cols, 1, 1, 1, 8, 8, 8, 1, 1, singleHistogramSize, false, hist);
								break;
							case 2:
								HOG_TOP(vecImgPieceB, i, vecImgPieceB[0].rows, vecImgPieceB[0].cols, 1, 1, 1, 8, hist);
								break;
							case 3:
								volume_HOG(vecImgPieceB, i, vecImgPieceB[0].rows, vecImgPieceB[0].cols, 1, 1, 1, 8, hist);
								break;
						};
						for (ri = 0; ri < 3; ri++){
							for (rj = 0; rj < singleHistogramSize; rj++){
								out << hist.at<float>(ri, rj) << "\n";
							}
						}
						switch (method){
							case 0:
								LBP_TOP(vecImgPieceG, i, vecImgPieceG[0].rows, vecImgPieceG[0].cols, 1, 1, 1, 8, 8, 8, 1, 1, singleHistogramSize, false, hist);
								break;
							case 1:
								volume_LBP(vecImgPieceG, i, vecImgPieceG[0].rows, vecImgPieceG[0].cols, 1, 1, 1, 8, 8, 8, 1, 1, singleHistogramSize, false, hist);
								break;
							case 2:
								HOG_TOP(vecImgPieceG, i, vecImgPieceG[0].rows, vecImgPieceG[0].cols, 1, 1, 1, 8, hist);
								break;
							case 3:
								volume_HOG(vecImgPieceG, i, vecImgPieceG[0].rows, vecImgPieceG[0].cols, 1, 1, 1, 8, hist);
								break;
						};
						for (ri = 0; ri < 3; ri++){
							for (rj = 0; rj < singleHistogramSize; rj++){
								out << hist.at<float>(ri, rj) << "\n";
							}
						}
						switch (method){
							case 0:
								LBP_TOP(vecImgPieceR, i, vecImgPieceR[0].rows, vecImgPieceR[0].cols, 1, 1, 1, 8, 8, 8, 1, 1, singleHistogramSize, false, hist);
								break;
							case 1:
								volume_LBP(vecImgPieceR, i, vecImgPieceR[0].rows, vecImgPieceR[0].cols, 1, 1, 1, 8, 8, 8, 1, 1, singleHistogramSize, false, hist);
								break;
							case 2:
								HOG_TOP(vecImgPieceR, i, vecImgPieceR[0].rows, vecImgPieceR[0].cols, 1, 1, 1, 8, hist);
								break;
							case 3:
								volume_HOG(vecImgPieceR, i, vecImgPieceR[0].rows, vecImgPieceR[0].cols, 1, 1, 1, 8, hist);
								break;
						}
						for (ri = 0; ri < 3; ri++){
							for (rj = 0; rj < singleHistogramSize; rj++){
								out << hist.at<float>(ri, rj) << "\n";
							}
						}
					}
				}
				out.close();
				str = get_string_id2(j + 100000, id, "data\\");
				std::vector <Mat> imagel;
				Mat imgout;
				imagel.push_back(vecImgB[i / 2]);
				imagel.push_back(vecImgG[i / 2]);
				imagel.push_back(vecImgR[i / 2]);
				merge(imagel, imgout);
				imwrite(str, imgout);
				//std::cout << "image" << truecases << "\n";
			}
		}
			falsecases = falsecases + falseadd;
			falseadd = 1;
			//std::cout << "falsecount: " << falsecases << endl;

	}

	std::cout << "Results: " << "\tTrueCases: " << truecases << "\tfalseCases: " << falsecases << "\n";
//	getchar();

	return 0;

}